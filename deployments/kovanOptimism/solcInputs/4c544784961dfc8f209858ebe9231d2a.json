{
  "language": "Solidity",
  "sources": {
    "src/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed require messages to save space\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../interfaces/IERC677Receiver.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\n\nabstract contract ERC20 is IERC20 {\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    uint8 public override decimals;\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        if (currentAllowance < (1 << 255)){\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in /doc/infiniteallowance.md\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external virtual returns (bool) {\n        bool success = transfer(recipient, amount);\n        if (success){\n            success = IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\n        }\n        return success;\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(address(0), recipient, amount);\n\n        _totalSupply += amount;\n        _balances[recipient] += amount;\n        emit Transfer(address(0), recipient, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        _balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\n    }\n}"
    },
    "src/ERC20/IERC20.sol": {
      "content": "/**\n* SPDX-License-Identifier: MIT\n*\n* Copyright (c) 2016-2019 zOS Global Limited\n*\n*/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    // Optional functions\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    event NameChanged(string name, string symbol);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "src/interfaces/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677Receiver {\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "src/shares/LicensedBrokerbot.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* Proprietary License\n*\n* This code cannot be used without an explicit permission from the copyright holder.\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\n*\n* Copyright (c) 2021 Aktionariat AG (aktionariat.com), All rights reserved.\n*/\npragma solidity ^0.8.0;\n\nimport \"../utils/Ownable.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../interfaces/ITokenReceiver.sol\";\nimport \"../interfaces/IERC677Receiver.sol\";\n\ncontract LicensedBrokerbot is Ownable {\n\n    address public paymenthub;\n\n    address public immutable base;  // ERC-20 currency\n    address public immutable token; // ERC-20 share token\n\n    uint256 private price; // current offer price, without drift\n    uint256 public increment; // increment\n\n    uint256 public driftStart;\n    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\n    int256 public driftIncrement;\n\n    uint8 private constant BUYING_ENABLED = 0x1;\n    uint8 private constant SELLING_ENABLED = 0x2;\n\n    // more bits to be used by payment hub\n    uint256 public settings = BUYING_ENABLED | SELLING_ENABLED;\n\n    event Trade(address indexed token, address who, bytes ref, int amount, address base, uint totPrice, uint fee, uint newprice);\n\n    constructor(\n        address _shareToken,\n        uint256 _price,\n        uint256 _increment,\n        address _baseCurrency,\n        address _owner\n    )\n        Ownable(_owner)\n    {\n        base = _baseCurrency;\n        token = _shareToken;\n        price = _price;\n        increment = _increment;\n        paymenthub = address(0x4d99F8e88BAB0BEe8cD840b1Ad3c0bE4f49c293A);\n    }\n\n    function setPrice(uint256 newPrice, uint256 newIncrement) external onlyOwner {\n        anchorPrice(newPrice);\n        increment = newIncrement;\n    }\n\n    function hasDrift() public view returns (bool) {\n        return timeToDrift != 0;\n    }\n\n    // secondsPerStep should be negative for downwards drift\n    function setDrift(uint256 secondsPerStep, int256 newDriftIncrement) external onlyOwner {\n        anchorPrice(getPrice());\n        timeToDrift = secondsPerStep;\n        driftIncrement = newDriftIncrement;\n    }\n\n    function anchorPrice(uint256 currentPrice) private {\n        price = currentPrice;\n        driftStart = block.timestamp;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return getPriceAtTime(block.timestamp);\n    }\n\n    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\n        if (hasDrift()){\n            uint256 passed = timestamp - driftStart;\n            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\n            int256 driftedPrice = int256(price) + drifted;\n            if (driftedPrice < 0){\n                return 0;\n            } else {\n                return uint256(driftedPrice);\n            }\n        } else {\n            return price;\n        }\n    }\n\n    function buy(address from, uint256 paid, bytes calldata ref) internal returns (uint256) {\n        uint shares = getShares(paid);\n        uint costs = notifyTraded(from, shares, ref);\n        if (costs < paid){\n            IERC20(base).transfer(from, paid - costs);\n        }\n        IERC20(token).transfer(from, shares);\n        return shares;\n    }\n\n    function notifyTraded(address from, uint256 shares, bytes calldata ref) internal returns (uint256) {\n        require(hasSetting(BUYING_ENABLED));\n        uint costs = getBuyPrice(shares);\n        price = price + (shares * increment);\n        emit Trade(token, from, ref, int256(shares), base, costs, 0, getPrice());\n        return costs;\n    }\n\n    function notifyTrade(address buyer, uint256 shares, bytes calldata ref) external onlyOwner {\n        notifyTraded(buyer, shares, ref);\n    }\n\n    function notifyTradeAndTransfer(address buyer, uint256 shares, bytes calldata ref) public onlyOwner {\n        notifyTraded(buyer, shares, ref);\n        IERC20(token).transfer(buyer, shares);\n    }\n\n    function notifyTrades(address[] calldata buyers, uint256[] calldata shares, bytes[] calldata ref) external onlyOwner {\n        for (uint i = 0; i < buyers.length; i++) {\n            notifyTraded(buyers[i], shares[i], ref[i]);\n        }\n    }\n\n    function notifyTradesAndTransfer(address[] calldata buyers, uint256[] calldata shares, bytes[] calldata ref) external onlyOwner {\n        for (uint i = 0; i < buyers.length; i++) {\n            notifyTradeAndTransfer(buyers[i], shares[i], ref[i]);\n        }\n    }\n\n    /**\n     * Payment hub might actually have sent another accepted token, including Ether.\n     */\n    function processIncoming(address token_, address from, uint256 amount, bytes calldata ref) public payable returns (uint256) {\n        require(msg.sender == token_ || msg.sender == base || msg.sender == paymenthub);\n        if (token_ == token){\n            return sell(from, amount, ref);\n        } else if (token_ == base){\n            return buy(from, amount, ref);\n        } else {\n            require(false);\n            return 0;\n        }\n    }\n\n    // ERC-677 recipient\n    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) external returns (bool) {\n        processIncoming(msg.sender, from, amount, ref);\n        return true;\n    }\n\n    // ITokenReceiver\n    function onTokenTransfer(address token_, address from, uint256 amount, bytes calldata ref) external {\n        processIncoming(token_, from, amount, ref);\n    }\n\n    function buyingEnabled() external view returns (bool){\n        return hasSetting(BUYING_ENABLED);\n    }\n\n    function sellingEnabled() external view returns (bool){\n        return hasSetting(SELLING_ENABLED);\n    }\n\n    function hasSetting(uint256 setting) private view returns (bool) {\n        return settings & setting == setting;\n    }\n\n    function sell(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\n        require(hasSetting(SELLING_ENABLED));\n        uint256 totPrice = getSellPrice(amount);\n        IERC20 baseToken = IERC20(base);\n        baseToken.transfer(recipient, totPrice);\n        price -= amount * increment;\n        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, 0, getPrice());\n        return totPrice;\n    }\n\n    function getLicenseFee(uint256) external pure returns (uint256) {\n        return 0;\n    }\n\n    function getSellPrice(uint256 shares) public view returns (uint256) {\n        return getPrice(getPrice() - (shares * increment), shares);\n    }\n\n    function getBuyPrice(uint256 shares) public view returns (uint256) {\n        return getPrice(getPrice(), shares);\n    }\n\n    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\n        if (shares == 0) {\n            return 0;\n        } else {\n            uint256 highest = lowest + (shares - 1) * increment;\n            return ((lowest + highest) / 2) * shares;\n        }\n    }\n\n    function getShares(uint256 money) public view returns (uint256) {\n        uint256 currentPrice = getPrice();\n        uint256 min = 0;\n        uint256 max = money / currentPrice;\n        while (min < max){\n            uint256 middle = (min + max)/2;\n            uint256 totalPrice = getPrice(currentPrice, middle);\n            if (money > totalPrice){\n                min = middle + 1;\n            } else {\n                max = middle;\n            }\n        }\n        return min;\n    }\n\n    function withdrawEther(uint256 amount) external ownerOrHub() {\n        payable(msg.sender).transfer(amount); // return change\n    }\n\n    function approve(address erc20, address who, uint256 amount) external onlyOwner() {\n        IERC20(erc20).approve(who, amount);\n    }\n\n    function withdraw(address ercAddress, address to, uint256 amount) external ownerOrHub() {\n        IERC20(ercAddress).transfer(to, amount);\n    }\n\n    function setPaymentHub(address hub) external onlyOwner() {\n        paymenthub = hub;\n    }\n\n    function setSettings(uint256 settings_) external onlyOwner() {\n        settings = settings_;\n    }\n\n    function setEnabled(bool newBuyingEnabled, bool newSellingEnabled) external onlyOwner() {\n        if (newBuyingEnabled != hasSetting(BUYING_ENABLED)){\n            settings ^= BUYING_ENABLED;\n        }\n        if (newSellingEnabled != hasSetting(SELLING_ENABLED)){\n            settings ^= SELLING_ENABLED;\n        }\n    }\n    \n    modifier ownerOrHub() {\n        require(owner == msg.sender || paymenthub == msg.sender, \"not owner\");\n        _;\n    }\n}"
    },
    "src/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n// - Extracted interface\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        owner = initialOwner;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"not owner\");\n        _;\n    }\n}"
    },
    "src/interfaces/ITokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol\npragma solidity ^0.8.0;\n\ninterface ITokenReceiver {\n\n    function onTokenTransfer(address token, address from, uint256 amount, bytes calldata data) external;\n\n}"
    },
    "src/shares/PaymentHub.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"../interfaces/IUniswapV3.sol\";\nimport \"../interfaces/ITokenReceiver.sol\";\n\n/**\n * A hub for payments. This allows tokens that do not support ERC 677 to enjoy similar functionality,\n * namely interacting with a token-handling smart contract in one transaction, without having to set an allowance first.\n * Instead, an allowance needs to be set only once, namely for this contract.\n * Further, it supports automatic conversion from Ether to the payment currency through Uniswap.\n */\ncontract PaymentHub {\n\n    address public immutable weth; \n    address public immutable currency;\n    \n    IQuoter constant uniswapQuoter = IQuoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n    ISwapRouter constant uniswapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n\n    constructor(address currency_) {\n        currency = currency_;\n        weth = uniswapQuoter.WETH9();\n    }\n\n    function getPriceInEther(uint256 amountOfXCHF) external returns (uint256) {\n        return uniswapQuoter.quoteExactOutputSingle(weth, currency, 3000, amountOfXCHF, 0);\n    }\n\n    /**\n     * Convenience method to swap ether into currency and pay a target address\n     */\n    function payFromEther(address recipient, uint256 xchfamount) payable public {\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams(\n            weth,\n            currency,\n            3000,\n            recipient,\n            block.timestamp,\n            xchfamount,\n            msg.value,\n            0\n        );\n\n        // Executes the swap returning the amountIn needed to spend to receive the desired amountOut.\n        uint256 amountIn = uniswapRouter.exactOutputSingle{value: msg.value}(params);\n\n        // For exact output swaps, the amountInMaximum may not have all been spent.\n        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.\n        if (amountIn < msg.value) {\n            uniswapRouter.refundETH();\n            payable(msg.sender).transfer(msg.value - amountIn); // return change\n        }\n    }\n\n    function multiPay(address[] calldata recipients, uint256[] calldata amounts) external {\n        multiPay(currency, recipients, amounts);\n    }\n\n    function multiPay(address token, address[] calldata recipients, uint256[] calldata amounts) public {\n        for (uint i=0; i<recipients.length; i++) {\n            IERC20(token).transferFrom(msg.sender, recipients[i], amounts[i]);\n        }\n    }\n\n    /**\n     * Can (at least in theory) save some gas as the sender balance only is touched in one transaction.\n     */\n    function multiPayAndNotify(address token, address[] calldata recipients, uint256[] calldata amounts, bytes calldata ref) external {\n        for (uint i=0; i<recipients.length; i++) {\n            payAndNotify(token, recipients[i], amounts[i], ref);\n        }\n    }\n\n    // Allows to make a payment from the sender to an address given an allowance to this contract\n    // Equivalent to xchf.transferAndCall(recipient, xchfamount)\n    function payAndNotify(address recipient, uint256 xchfamount, bytes calldata ref) external {\n        payAndNotify(currency, recipient, xchfamount, ref);\n    }\n\n    function payAndNotify(address token, address recipient, uint256 amount, bytes calldata ref) public {\n        IERC20(token).transferFrom(msg.sender, recipient, amount);\n        ITokenReceiver(recipient).onTokenTransfer(token, msg.sender, amount, ref);\n    }\n\n    function payFromEtherAndNotify(address recipient, uint256 xchfamount, bytes calldata ref) payable external {\n        payFromEther(recipient, xchfamount);\n        ITokenReceiver(recipient).onTokenTransfer(address(currency), msg.sender, xchfamount, ref);\n    }\n\n    /**\n     * In case tokens have been accidentally sent directly to this contract.\n     * Make sure to be fast as anyone can call this!\n     */\n    function recover(address ercAddress, address to, uint256 amount) external {\n        IERC20(ercAddress).transfer(to, amount);\n    }\n\n    // Important to receive ETH refund from Uniswap\n    receive() payable external {}\n}"
    },
    "src/interfaces/IUniswapV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol\npragma solidity ^0.8.0;\n\ninterface IQuoter {\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n    \n    function WETH9() external view returns (address);\n}\n\ninterface ISwapRouter {\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n    \n    function refundETH() external payable;\n}"
    },
    "src/shares/Offer.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./draggable/IDraggable.sol\";\n/**\n * @title Acquisition Attempt\n * @author Luzius Meisser, luzius@aktionariat.com\n */\n\ncontract Offer {\n\n    uint256 public immutable quorum;                    // Percentage of votes needed to start drag-along process in BPS, i.e. 10'000 = 100%\n\n    IDraggable public immutable token;\n    address public immutable buyer;                     // who made the offer\n    \n    IERC20 public immutable currency;\n    uint256 public immutable price;                               // the price offered per share\n\n    enum Vote { NONE, YES, NO }                         // Used internally, represents not voted yet or yes/no vote.\n    mapping (address => Vote) private votes;            // Who votes what\n    uint256 public yesVotes;                            // total number of yes votes, including external votes\n    uint256 public noVotes;                             // total number of no votes, including external votes\n    uint256 public noExternal;                          // number of external no votes reported by oracle\n    uint256 public yesExternal;                         // number of external yes votes reported by oracle\n\n    uint256 public immutable voteEnd;                             // end of vote period in block time (seconds after 1.1.1970)\n\n    event VotesChanged(uint256 newYesVotes, uint256 newNoVotes);\n    event OfferCreated(address indexed buyer, address token, uint256 pricePerShare, address currency);\n    event OfferEnded(address indexed buyer, bool success, string message);\n\n    // Not checked here, but buyer should make sure it is well funded from the beginning\n    constructor(\n        address _buyer,\n        address _token,\n        uint256 _price,\n        address _currency,\n        uint256 _quorum,\n        uint256 _votePeriod\n    ) \n        payable \n    {\n        buyer = _buyer;\n        token = IDraggable(_token);\n        currency = IERC20(_currency);\n        price = _price;\n        quorum = _quorum;\n        voteEnd = block.timestamp + _votePeriod;\n        // License Fee to Aktionariat AG, also ensures that offer is serious.\n        // Any circumvention of this license fee payment is a violation of the copyright terms.\n        payable(0x29Fe8914e76da5cE2d90De98a64d0055f199d06D).transfer(3 ether);\n        emit OfferCreated(_buyer, address(_token), _price, address(_currency));\n    }\n\n    function makeCompetingOffer(address betterOffer) external {\n        require(msg.sender == address(token));\n        Offer better = Offer(betterOffer);\n        require(!isAccepted(), \"old already accepted\");\n        require(currency == better.currency() && better.price() > price, \"old offer better\");\n        require(better.isWellFunded(), \"not funded\");\n        kill(false, \"replaced\");\n    }\n\n    function hasExpired() internal view returns (bool) {\n        return block.timestamp > voteEnd + 30 days; // buyer has thirty days to complete acquisition after voting ends\n    }\n\n    function contest() external {\n        if (hasExpired()) {\n            kill(false, \"expired\");\n        } else if (isDeclined()) {\n            kill(false, \"declined\");\n        } else if (!isWellFunded()) {\n            kill(false, \"lack of funds\");\n        }\n    }\n\n    function cancel() external {\n        require(msg.sender == buyer);\n        kill(false, \"cancelled\");\n    }\n\n    function execute() external {\n        require(msg.sender == buyer, \"not buyer\");\n        require(isAccepted(), \"not accepted\");\n        uint256 totalPrice = getTotalPrice();\n        require(currency.transferFrom(buyer, address(token), totalPrice));\n        token.drag(buyer, address(currency));\n        kill(true, \"success\");\n    }\n\n    function getTotalPrice() internal view returns (uint256) {\n        IERC20 tok = IERC20(address(token));\n        return (tok.totalSupply() - tok.balanceOf(buyer)) * price;\n    }\n\n    function isWellFunded() public view returns (bool) {\n        uint256 buyerBalance = currency.balanceOf(buyer);\n        uint256 totalPrice = getTotalPrice();\n        return totalPrice <= buyerBalance;\n    }\n\n    function isAccepted() public view returns (bool) {\n        if (isVotingOpen()) {\n            // is it already clear that 75% will vote yes even though the vote is not over yet?\n            return yesVotes * 10000  >= quorum * IDraggable(token).totalVotingTokens();\n        } else {\n            // did 75% of all cast votes say 'yes'?\n            return yesVotes * 10000 >= quorum * (yesVotes + noVotes);\n        }\n    }\n\n    function isDeclined() public view returns (bool) {\n        if (isVotingOpen()) {\n            // is it already clear that 25% will vote no even though the vote is not over yet?\n            uint256 supply = token.totalVotingTokens();\n            return (supply - noVotes) * 10000 < quorum * supply;\n        } else {\n            // did quorum% of all cast votes say 'no'?\n            return 10000 * yesVotes < quorum * (yesVotes + noVotes);\n        }\n    }\n\n    function notifyMoved(address from, address to, uint256 value) external {\n        require(msg.sender == address(token));\n        if (isVotingOpen()) {\n            Vote fromVoting = votes[from];\n            Vote toVoting = votes[to];\n            update(fromVoting, toVoting, value);\n        }\n    }\n\n    function update(Vote previousVote, Vote newVote, uint256 votes_) internal {\n        if (previousVote != newVote) {\n            if (previousVote == Vote.NO) {\n                noVotes = noVotes - votes_;\n            } else if (previousVote == Vote.YES) {\n                yesVotes = yesVotes - votes_;\n            }\n            if (newVote == Vote.NO) {\n                noVotes = noVotes + votes_;\n            } else if (newVote == Vote.YES) {\n                yesVotes = yesVotes + votes_;\n            }\n            emit VotesChanged(yesVotes, noVotes);\n        }\n    }\n\n    function isVotingOpen() public view returns (bool) {\n        return block.timestamp <= voteEnd;\n    }\n\n    modifier votingOpen() {\n        require(isVotingOpen(), \"vote ended\");\n        _;\n    }\n\n    /**\n     * Function to allow the oracle to report the votes of external votes (e.g. shares tokenized on other blockchains).\n     * This functions is idempotent and sets the number of external yes and no votes. So when more votes come in, the\n     * oracle should always report the total number of yes and no votes. Abstentions are not counted.\n     */\n    function reportExternalVotes(uint256 yes, uint256 no) external {\n        require(msg.sender == token.getOracle(), \"not oracle\");\n        require(yes + no + IERC20(address(token)).totalSupply() <= token.totalVotingTokens(), \"too many votes\");\n        // adjust total votes taking into account that the oralce might have reported different counts before\n        yesVotes = yesVotes - yesExternal + yes;\n        noVotes = noVotes - noExternal + no;\n        // remember how the oracle voted in case the oracle later reports updated numbers\n        yesExternal = yes;\n        noExternal = no;\n    }\n\n    function voteYes() external {\n        vote(Vote.YES);\n    }\n\n    function voteNo() external { \n        vote(Vote.NO);\n    }\n\n    function vote(Vote newVote) internal votingOpen() {\n        Vote previousVote = votes[msg.sender];\n        votes[msg.sender] = newVote;\n        if(previousVote == Vote.NONE){\n            IDraggable(token).notifyVoted(msg.sender);\n        }\n        update(previousVote, newVote, IDraggable(token).votingPower(msg.sender));\n    }\n\n    function hasVotedYes(address voter) external view returns (bool) {\n        return votes[voter] == Vote.YES;\n    }\n\n    function hasVotedNo(address voter) external view returns (bool) {\n        return votes[voter] == Vote.NO;\n    }\n\n    function kill(bool success, string memory message) internal {\n        IDraggable(token).notifyOfferEnded();\n        emit OfferEnded(buyer, success, message);\n        selfdestruct(payable(buyer));\n    }\n\n}"
    },
    "src/shares/draggable/IDraggable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract IDraggable {\n    \n    function getOracle() public virtual returns (address);\n    function drag(address buyer, address currency) external virtual;\n    function notifyOfferEnded() external virtual;\n    function votingPower(address voter) external virtual returns (uint256);\n    function totalVotingTokens() public virtual view returns (uint256);\n    function notifyVoted(address voter) external virtual;\n\n}"
    },
    "src/shares/OfferFactory.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./Offer.sol\";\n\ncontract OfferFactory {\n    \n    event OfferCreated(address contractAddress, string typeName);\n\n    // It must be possible to predict the address of the offer so one can pre-fund the allowance.\n    function predict(bytes32 salt, address buyer, address token, uint256 pricePerShare, address currency, uint256 quorum, uint256 votePeriod) external view returns (address) {\n        bytes32 initCodeHash = keccak256(abi.encodePacked(type(Offer).creationCode, abi.encode(buyer, token, pricePerShare, currency, quorum, votePeriod)));\n        bytes32 hashResult = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash));\n        return address(uint160(uint256(hashResult)));\n    }\n\n    // Do not call directly, msg.sender must be the token to be acquired\n    function create(bytes32 salt, address buyer, uint256 pricePerShare, address currency, uint256 quorum, uint256 votePeriod) external payable returns (address) {\n        Offer offer = new Offer{value: msg.value, salt: salt}(buyer, msg.sender, pricePerShare, currency, quorum, votePeriod);\n        return address(offer);\n    }\n}"
    },
    "src/shares/draggable/ERC20Draggable.sol": {
      "content": "/**\n * SPDX-License-Identifier: LicenseRef-Aktionariat\n *\n * MIT License with Automated License Fee Payments\n *\n * Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n *\n * Permission is hereby granted to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - All automated license fee payments integrated into this and related Software\n *   are preserved.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npragma solidity ^0.8.0;\n\n/**\n * @title CompanyName Shareholder Agreement\n * @author Luzius Meisser, luzius@aktionariat.com\n * @dev These tokens are based on the ERC20 standard and the open-zeppelin library.\n *\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\n * a shareholder agreement that can be found at the URL defined in the constant 'terms'\n * of the 'DraggableCompanyNameShares' contract. The agreement is partially enforced\n * through the Swiss legal system, and partially enforced through this smart contract.\n * In particular, this smart contract implements a drag-along clause which allows the\n * majority of token holders to force the minority sell their shares along with them in\n * case of an acquisition. That's why the tokens are called \"Draggable CompanyName AG Shares.\"\n */\n\nimport \"./IDraggable.sol\";\nimport \"../../ERC20/extensions/ERC20Flaggable.sol\";\nimport \"../../ERC20/IERC20.sol\";\nimport \"../../interfaces/IERC677Receiver.sol\";\n\nabstract contract ERC20Draggable is ERC20Flaggable, IERC677Receiver, IDraggable {\n    \n\tuint8 private constant FLAG_VOTED = 1;\n\n\tIERC20 public wrapped; // The wrapped contract\n\tIOfferFactory public immutable factory;\n\n\t// If the wrapped tokens got replaced in an acquisition, unwrapping might yield many currency tokens\n\tuint256 public unwrapConversionFactor = 0;\n\n\t// The current acquisition attempt, if any. See initiateAcquisition to see the requirements to make a public offer.\n\tIOffer public offer;\n\n\tuint256 public immutable quorum; // BPS (out of 10'000)\n\tuint256 public immutable votePeriod; // Seconds\n\n\taddress private oracle;\n\n\tevent MigrationSucceeded(\n\t\taddress newContractAddress,\n\t\tuint256 yesVotes,\n\t\tuint256 oracleVotes,\n\t\tuint256 totalVotingPower\n\t);\n\n\tconstructor(\n\t\taddress _wrappedToken,\n\t\tuint256 _quorum,\n\t\tuint256 _votePeriod,\n\t\taddress _offerFactory,\n\t\taddress _oracle\n\t) {\n\t\twrapped = IERC20(_wrappedToken);\n\t\tquorum = _quorum;\n\t\tvotePeriod = _votePeriod;\n\t\tfactory = IOfferFactory(_offerFactory);\n\t\toracle = _oracle;\n\t}\n\n\tfunction onTokenTransfer(\n\t\taddress from,\n\t\tuint256 amount,\n\t\tbytes calldata\n\t) external override returns (bool) {\n\t\trequire(msg.sender == address(wrapped));\n\t\t_mint(from, amount);\n\t\treturn true;\n\t}\n\n\t/** Increases the number of drag-along tokens. Requires minter to deposit an equal amount of share tokens */\n\tfunction wrap(address shareholder, uint256 amount) external {\n\t\trequire(wrapped.transferFrom(msg.sender, address(this), amount));\n\t\t_mint(shareholder, amount);\n\t}\n\n\t/**\n\t * Indicates that the token holders are bound to the token terms and that:\n\t * - Conversions back to the wrapped token (unwrap) are not allowed\n\t * - The drag-along can be performed by making an according offer\n\t * - They can be migrated to a new version of this contract in accordance with the terms\n\t */\n\tfunction isBinding() public view returns (bool) {\n\t\treturn unwrapConversionFactor == 0;\n\t}\n\n\tfunction name() public view override returns (string memory) {\n\t\tif (isBinding()) {\n\t\t\treturn string(abi.encodePacked(wrapped.name(), \" SHA\"));\n\t\t} else {\n\t\t\treturn string(abi.encodePacked(wrapped.name(), \" (Wrapped)\"));\n\t\t}\n\t}\n\n\tfunction symbol() public view override returns (string memory) {\n\t\t// ticker should be less dynamic than name\n\t\treturn string(abi.encodePacked(wrapped.symbol(), \"S\"));\n\t}\n\n\t/**\n\t * Deactivates the drag-along mechanism and enables the unwrap function.\n\t */\n\tfunction deactivate(uint256 factor) internal {\n\t\trequire(factor >= 1, \"factor\");\n\t\tunwrapConversionFactor = factor;\n\t\temit NameChanged(name(), symbol());\n\t}\n\n\t/** Decrease the number of drag-along tokens. The user gets back their shares in return */\n\tfunction unwrap(uint256 amount) external {\n\t\trequire(!isBinding());\n\t\tunwrap(msg.sender, amount, unwrapConversionFactor);\n\t}\n\n\tfunction unwrap(\n\t\taddress owner,\n\t\tuint256 amount,\n\t\tuint256 factor\n\t) internal {\n\t\t_burn(owner, amount);\n\t\trequire(wrapped.transfer(owner, amount * factor));\n\t}\n\n\t/**\n\t * Burns both the token itself as well as the wrapped token!\n\t * If you want to get out of the shareholder agreement, use unwrap after it has been\n\t * deactivated by a majority vote or acquisition.\n\t *\n\t * Burning only works if wrapped token supports burning. Also, the exact meaning of this\n\t * operation might depend on the circumstances. Burning and reussing the wrapped token\n\t * does not free the sender from the legal obligations of the shareholder agreement.\n\t */\n\tfunction burn(uint256 amount) external {\n\t\t_burn(msg.sender, amount);\n\t\tuint256 factor = isBinding() ? 1 : unwrapConversionFactor;\n\t\tIShares(address(wrapped)).burn(amount * factor);\n\t}\n\n\tfunction makeAcquisitionOffer(\n\t\tbytes32 salt,\n\t\tuint256 pricePerShare,\n\t\taddress currency\n\t) external payable {\n\t\trequire(isBinding());\n\t\taddress newOffer = factory.create{value: msg.value}(\n\t\t\tsalt,\n\t\t\tmsg.sender,\n\t\t\tpricePerShare,\n\t\t\tcurrency,\n\t\t\tquorum,\n\t\t\tvotePeriod\n\t\t);\n\n\t\tif (offerExists()) {\n\t\t\toffer.makeCompetingOffer(newOffer);\n\t\t}\n\t\toffer = IOffer(newOffer);\n\t}\n\n\tfunction drag(address buyer, address currency) external override {\n\t\trequire(msg.sender == address(offer));\n\t\tunwrap(buyer, balanceOf(buyer), 1);\n\t\treplaceWrapped(currency, buyer);\n\t}\n\n\tfunction notifyOfferEnded() external override {\n\t\tif (msg.sender == address(offer)) {\n\t\t\toffer = IOffer(address(0));\n\t\t}\n\t}\n\n\tfunction replaceWrapped(address newWrapped, address oldWrappedDestination) internal {\n\t\trequire(isBinding());\n\t\t// Free all old wrapped tokens we have\n\t\trequire(wrapped.transfer(oldWrappedDestination, wrapped.balanceOf(address(this))));\n\t\t// Count the new wrapped tokens\n\t\twrapped = IERC20(newWrapped);\n\t\tdeactivate(wrapped.balanceOf(address(this)) / totalSupply());\n\t}\n\n\tfunction getOracle() public view override returns (address) {\n\t\treturn oracle;\n\t}\n\n\tfunction setOracle(address newOracle) external {\n\t\trequire(msg.sender == oracle, \"not oracle\");\n\t\toracle = newOracle;\n\t}\n\n\tfunction migrateWithExternalApproval(address target, uint256 externalSupportingVotes) external {\n\t\trequire(msg.sender == oracle);\n\t\t// Additional votes cannot be higher than the votes not represented by these tokens.\n\t\t// The assumption here is that more shareholders are bound to the shareholder agreement\n\t\t// that this contract helps enforce and a vote among all parties is necessary to change\n\t\t// it, with an oracle counting and reporting the votes of the others.\n\t\trequire(totalSupply() + externalSupportingVotes <= totalVotingTokens());\n\t\tmigrate(target, externalSupportingVotes);\n\t}\n\n\tfunction migrate() external {\n\t\tmigrate(msg.sender, 0);\n\t}\n\n\tfunction migrate(address successor, uint256 additionalVotes) internal {\n\t\tuint256 yesVotes = additionalVotes + balanceOf(successor);\n\t\tuint256 totalVotes = totalVotingTokens();\n\t\trequire(yesVotes < totalVotes);\n\t\trequire(!offerExists()); // if you have the quorum, you can cancel the offer first if necessary\n\t\trequire(yesVotes * 10000 >= totalVotes * quorum, \"quorum\");\n\t\treplaceWrapped(successor, successor);\n\t\temit MigrationSucceeded(successor, yesVotes, additionalVotes, totalVotes);\n\t}\n\n\tfunction votingPower(address voter) external view override returns (uint256) {\n\t\treturn balanceOf(voter);\n\t}\n\n\tfunction totalVotingTokens() public view override returns (uint256) {\n\t\treturn IShares(address(wrapped)).totalShares();\n\t}\n\n\tfunction hasVoted(address voter) internal view returns (bool) {\n\t\treturn hasFlagInternal(voter, FLAG_VOTED);\n\t}\n\n\tfunction notifyVoted(address voter) external override {\n\t\tsetFlag(voter, FLAG_VOTED, true);\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual override {\n\t\tif (hasVoted(from) || hasVoted(to)) {\n\t\t\tif (offerExists()) {\n\t\t\t\toffer.notifyMoved(from, to, amount);\n\t\t\t} else {\n\t\t\t\tsetFlag(from, FLAG_VOTED, false);\n\t\t\t\tsetFlag(to, FLAG_VOTED, false);\n\t\t\t}\n\t\t}\n\t\tsuper._beforeTokenTransfer(from, to, amount);\n\t}\n\n\tfunction offerExists() internal view returns (bool) {\n\t\treturn address(offer) != address(0);\n\t}\n}\n\nabstract contract IShares {\n\tfunction burn(uint256) external virtual;\n\n\tfunction totalShares() external view virtual returns (uint256);\n}\n\nabstract contract IOffer {\n\tfunction makeCompetingOffer(address newOffer) external virtual;\n\n\tfunction notifyMoved(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external virtual;\n}\n\nabstract contract IOfferFactory {\n\tfunction create(\n\t\tbytes32 salt,\n\t\taddress buyer,\n\t\tuint256 pricePerShare,\n\t\taddress currency,\n\t\tuint256 quorum,\n\t\tuint256 votePeriod\n\t) external payable virtual returns (address);\n}\n"
    },
    "src/ERC20/extensions/ERC20Flaggable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n// - use upper 32 bits of balance for flags\n// - add a global settings variable\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../interfaces/IERC677Receiver.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\n\nabstract contract ERC20Flaggable is IERC20 {\n\n    uint256 private constant FLAGGING_MASK = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000;\n    uint256 private constant BALANCES_MASK = 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    // Documentation of flags used by subclasses:\n    // NOTE: flags denote the bit number that is being used and must be smaller than 32\n    // ERC20Draggable: uint8 private constant FLAG_INDEX_VOTED = 1;\n    // ERC20Recoverable: uint8 private constant FLAG_INDEX_CLAIM_PRESENT = 10;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\n    // ERCAllowlistable: uint8 private constant FLAG_INDEX_POWERLIST = 22;\n\n    mapping (address => uint256) private _balances; // lower 32 bits reserved for flags\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    uint8 public override decimals;\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account] & BALANCES_MASK;\n    }\n\n    function hasFlag(address account, uint8 number) external view returns (bool) {\n        return hasFlagInternal(account, number);\n    }\n\n    function setFlag(address account, uint8 index, bool value) internal returns (bool) {\n        if (hasFlagInternal(account, index) != value){\n            toggleFlag(account, index);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function hasFlagInternal(address account, uint8 number) internal view returns (bool) {\n        uint256 flag = 0x1 << (number + 224);\n        return _balances[account] & flag == flag;\n    }\n\n    function toggleFlag(address account, uint8 number) internal {\n        uint256 flag = 0x1 << (number + 224);\n        _balances[account] ^= flag;\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        if (currentAllowance < (1 << 255)){\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in /doc/infiniteallowance.md\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        _beforeTokenTransfer(sender, recipient, amount);\n        _balances[sender] -= amount;\n        increaseBalance(recipient, amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        bool success = transfer(recipient, amount);\n        if (success){\n            success = IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\n        }\n        return success;\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), recipient, amount);\n        _totalSupply += amount;\n        increaseBalance(recipient, amount);\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    function increaseBalance(address recipient, uint256 amount) private {\n        require(recipient != address(0x0)); // use burn instead\n        uint256 oldBalance = _balances[recipient];\n        uint256 oldSettings = oldBalance & FLAGGING_MASK;\n        uint256 newBalance = oldBalance + amount;\n        uint256 newSettings = newBalance & FLAGGING_MASK;\n        require(newSettings == oldSettings, \"overflow\");\n        _balances[recipient] = newBalance;\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        _balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\n    }\n}"
    },
    "src/shares/draggable/DraggableSharesWithPredecessor.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./DraggableShares.sol\";\nimport \"./ERC20Draggable.sol\";\n\n/**\n * @title Draggable CompanyName AG Shares\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\n * a shareholder agreement that can be found at the URL defined in the constant 'terms'.\n * The shareholder agreement is partially enforced through this smart contract. The agreement\n * is designed to facilitate a complete acquisition of the firm even if a minority of shareholders\n * disagree with the acquisition, to protect the interest of the minority shareholders by requiring\n * the acquirer to offer the same conditions to everyone when acquiring the company, and to\n * facilitate an update of the shareholder agreement even if a minority of the shareholders that\n * are bound to this agreement disagree. The name \"draggable\" stems from the convention of calling\n * the right to drag a minority along with a sale of the company \"drag-along\" rights. The name is\n * chosen to ensure that token holders are aware that they are bound to such an agreement.\n *\n * The percentage of token holders that must agree with an update of the terms is defined by the\n * constant UPDATE_QUORUM. The percentage of yes-votes that is needed to successfully complete an\n * acquisition is defined in the constant ACQUISITION_QUORUM. Note that the update quorum is based\n * on the total number of tokens in circulation. In contrast, the acquisition quorum is based on the\n * number of votes cast during the voting period, not taking into account those who did not bother\n * to vote.\n */\n\ncontract DraggableSharesWithPredecessor is DraggableShares {\n\n    address immutable newBaseToken;\n\n    constructor(\n        address _newBaseToken,\n        string memory _terms,\n        address _predecessor,\n        uint256 _quorum,\n        uint256 _votePeriod,\n        address _recoveryHub,\n        address _offerFactory,\n        address _oracle\n    )\n        DraggableShares(_terms, _predecessor, _quorum, _votePeriod, _recoveryHub, _offerFactory, _oracle)\n    {\n        newBaseToken = _newBaseToken;\n    }\n\n    // custom built convert function for old DSHS contract\n    function convert() external {\n        address oldBase = getOldBase();\n        fetchTokens();\n        switchBase(oldBase);\n    }\n\n    function fetchTokens() internal {\n        require(address(wrapped) != newBaseToken);\n        IDSHS predecessor = IDSHS(address(wrapped));\n        uint256 supply = predecessor.totalSupply();\n        uint256 present = totalSupply();\n        uint256 missing = supply - present;\n        //_mint(address(predecessor), supply); that's what the newer version expects\n        _mint(address(this), missing);\n        _approve(address(this), address(predecessor), missing);\n        predecessor.migrate();\n    }\n\n    function getOldBase() internal view returns (address) {\n        return IDSHS(address(wrapped)).getWrappedContract();\n    }\n\n    function switchBase(address oldWrapped) internal {\n        IERC20 oldBase = IERC20(oldWrapped);\n        oldBase.approve(newBaseToken, oldBase.balanceOf(address(this)));\n        IBaseToken(newBaseToken).convertOldShares();\n        wrapped = IERC20(newBaseToken);\n        recovery.setRecoverable(false);\n        require(totalSupply() == wrapped.balanceOf(address(this)));\n    }\n}\n\nabstract contract IBaseToken {\n    function convertOldShares() virtual external;\n}\n\nabstract contract IDSHS {\n    function migrate() virtual external;\n    function getWrappedContract() virtual view external returns (address);\n    function totalSupply() virtual external returns (uint256);\n}"
    },
    "src/shares/draggable/DraggableShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../../recovery/ERC20Recoverable.sol\";\nimport \"./ERC20Draggable.sol\";\n\n/**\n * @title Draggable CompanyName AG Shares\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\n * a shareholder agreement that can be found at the URL defined in the constant 'terms'.\n * The shareholder agreement is partially enforced through this smart contract. The agreement\n * is designed to facilitate a complete acquisition of the firm even if a minority of shareholders\n * disagree with the acquisition, to protect the interest of the minority shareholders by requiring\n * the acquirer to offer the same conditions to everyone when acquiring the company, and to\n * facilitate an update of the shareholder agreement even if a minority of the shareholders that\n * are bound to this agreement disagree. The name \"draggable\" stems from the convention of calling\n * the right to drag a minority along with a sale of the company \"drag-along\" rights. The name is\n * chosen to ensure that token holders are aware that they are bound to such an agreement.\n *\n * The percentage of token holders that must agree with an update of the terms is defined by the\n * constant UPDATE_QUORUM. The percentage of yes-votes that is needed to successfully complete an\n * acquisition is defined in the constant ACQUISITION_QUORUM. Note that the update quorum is based\n * on the total number of tokens in circulation. In contrast, the acquisition quorum is based on the\n * number of votes cast during the voting period, not taking into account those who did not bother\n * to vote.\n */\n\ncontract DraggableShares is ERC20Recoverable, ERC20Draggable {\n\n    string public terms;\n\n    constructor(\n        string memory _terms,\n        address _wrappedToken,\n        uint256 _quorumBps,\n        uint256 _votePeriodSeconds,\n        address _recoveryHub,\n        address _offerFactory,\n        address _oracle\n    )\n        ERC20Draggable(_wrappedToken, _quorumBps, _votePeriodSeconds, _offerFactory, _oracle) ERC20Flaggable(0) ERC20Recoverable(_recoveryHub) \n    {\n        terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\n        IRecoveryHub(address(_recoveryHub)).setRecoverable(false);\n    }\n\n    function transfer(address to, uint256 value) virtual override(ERC20Recoverable, ERC20Flaggable) public returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n     * Let the oracle act as deleter of invalid claims. In earlier versions, this was referring to the claim deleter\n     * of the wrapped token. But that stops working after a successful acquisition as the acquisition currency most\n     * likely does not have a claim deleter.\n     */\n    function getClaimDeleter() public view override returns (address) {\n        return getOracle();\n    }\n\n    function getCollateralRate(address collateralType) public view override returns (uint256) {\n        uint256 rate = super.getCollateralRate(collateralType);\n        if (rate > 0) {\n            return rate;\n        } else if (collateralType == address(wrapped)) {\n            return unwrapConversionFactor;\n        } else {\n            // If the wrapped contract allows for a specific collateral, we should too.\n            // If the wrapped contract is not IRecoverable, we will fail here, but would fail anyway.\n            return IRecoverable(address(wrapped)).getCollateralRate(collateralType) * unwrapConversionFactor;\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Draggable, ERC20Flaggable) internal {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n}"
    },
    "src/recovery/ERC20Recoverable.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/extensions/ERC20Flaggable.sol\";\nimport \"./IRecoveryHub.sol\";\nimport \"./IRecoverable.sol\";\n\n/**\n * @title Recoverable\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\n * declareLost function to post a deposit and claim that the shares assigned to a specific address are\n * lost. To prevent front running, a commit reveal scheme is used. If he actually is the owner of the shares,\n * he needs to wait for a certain period and can then reclaim the lost shares as well as the deposit.\n * If he is an attacker trying to claim shares belonging to someone else, he risks losing the deposit\n * as it can be claimed at anytime by the rightful owner.\n * Furthermore, if \"getClaimDeleter\" is defined in the subclass, the returned address is allowed to\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\n * function.\n */\n\nabstract contract ERC20Recoverable is ERC20Flaggable, IRecoverable {\n\n    uint8 private constant FLAG_CLAIM_PRESENT = 10;\n\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\n    address public customCollateralAddress;\n    uint256 public customCollateralRate;\n\n    IRecoveryHub public immutable recovery;\n\n    constructor(address recoveryHub){\n        recovery = IRecoveryHub(recoveryHub);\n    }\n\n    /**\n     * Returns the collateral rate for the given collateral type and 0 if that type\n     * of collateral is not accepted. By default, only the token itself is accepted at\n     * a rate of 1:1.\n     *\n     * Subclasses should override this method if they want to add additional types of\n     * collateral.\n     */\n    function getCollateralRate(address collateralType) public override virtual view returns (uint256) {\n        if (collateralType == address(this)) {\n            return 1;\n        } else if (collateralType == customCollateralAddress) {\n            return customCollateralRate;\n        } else {\n            return 0;\n        }\n    }\n\n    function claimPeriod() external pure override returns (uint256){\n        return 180 days;\n    }\n\n    /**\n     * Allows subclasses to set a custom collateral besides the token itself.\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\n     * throws an exception or returns false on failure.\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\n     */\n    function _setCustomClaimCollateral(address collateral, uint256 rate) internal {\n        customCollateralAddress = collateral;\n        if (customCollateralAddress == address(0)) {\n            customCollateralRate = 0; // disabled\n        } else {\n            require(rate > 0, \"zero\");\n            customCollateralRate = rate;\n        }\n    }\n\n    function getClaimDeleter() virtual public view returns (address);\n\n    function transfer(address recipient, uint256 amount) override virtual public returns (bool) {\n        require(super.transfer(recipient, amount));\n        if (hasFlagInternal(msg.sender, FLAG_CLAIM_PRESENT)){\n            recovery.clearClaimFromToken(msg.sender);\n        }\n        return true;\n    }\n\n    function notifyClaimMade(address target) external override {\n        require(msg.sender == address(recovery));\n        setFlag(target, FLAG_CLAIM_PRESENT, true);\n    }\n\n    function notifyClaimDeleted(address target) external override {\n        require(msg.sender == address(recovery));\n        setFlag(target, FLAG_CLAIM_PRESENT, false);\n    }\n\n    function deleteClaim(address lostAddress) external {\n        require(msg.sender == getClaimDeleter(), \"no access\");\n        recovery.deleteClaim(lostAddress);\n    }\n\n    function recover(address oldAddress, address newAddress) external override {\n        require(msg.sender == address(recovery));\n        _transfer(oldAddress, newAddress, balanceOf(oldAddress));\n    }\n\n}"
    },
    "src/recovery/IRecoveryHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract IRecoveryHub {\n\n    function setRecoverable(bool flag) external virtual;\n    \n    function deleteClaim(address target) external virtual;\n\n    function clearClaimFromToken(address holder) external virtual;\n\n}"
    },
    "src/recovery/IRecoverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract IRecoverable {\n\n    function claimPeriod() external view virtual returns (uint256);\n    \n    function notifyClaimMade(address target) external virtual;\n\n    function notifyClaimDeleted(address target) external virtual;\n\n    function getCollateralRate(address collateral) public view virtual returns(uint256);\n\n    function recover(address oldAddress, address newAddress) external virtual;\n\n}"
    },
    "src/shares/Shares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../ERC20/extensions/ERC20Named.sol\";\nimport \"../recovery/ERC20Recoverable.sol\";\nimport \"../interfaces/IERC677Receiver.sol\";\n\n/**\n * @title CompanyName AG Shares\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * These tokens are uncertified shares (Wertrechte according to the Swiss code of obligations),\n * with this smart contract serving as onwership registry (Wertrechtebuch), but not as shareholder\n * registry, which is kept separate and run by the company. This is equivalent to the traditional system\n * of having physical share certificates kept at home by the shareholders and a shareholder registry run by\n * the company. Just like with physical certificates, the owners of the tokens are the owners of the shares.\n * However, in order to exercise their rights (for example receive a dividend), shareholders must register\n * with the company. For example, in case the company pays out a dividend to a previous shareholder because\n * the current shareholder did not register, the company cannot be held liable for paying the dividend to\n * the \"wrong\" shareholder. In relation to the company, only the registered shareholders count as such.\n * Registration requires setting up an account with ledgy.com providing your name and address and proving\n * ownership over your addresses.\n * @notice The main addition is a functionality that allows the user to claim that the key for a certain address is lost.\n * @notice In order to prevent malicious attempts, a collateral needs to be posted.\n * @notice The contract owner can delete claims in case of disputes.\n */\ncontract Shares is ERC20Recoverable, ERC20Named {\n\n    string public terms;\n\n    uint256 public totalShares = 0; // total number of shares, maybe not all tokenized\n    uint256 public invalidTokens = 0;\n\n    event Announcement(string message);\n    event TokensDeclaredInvalid(address indexed holder, uint256 amount, string message);\n\n    constructor(\n        string memory _symbol,\n        string memory _name,\n        string memory _terms,\n        uint256 _totalShares,\n        address _owner,\n        address _recoveryHub\n    )\n        ERC20Named(_owner, _name, _symbol, 0) \n        ERC20Recoverable(_recoveryHub)\n    {\n        symbol = _symbol;\n        name = _name;\n        totalShares = _totalShares;\n        terms = _terms;\n    }\n\n    function setTerms(string memory _terms) external onlyOwner {\n        terms = _terms;\n    }\n\n    /**\n     * Declares the number of total shares, including those that have not been tokenized and those\n     * that are held by the company itself. This number can be substiantially higher than totalSupply()\n     * in case not all shares have been tokenized. Also, it can be lower than totalSupply() in case some\n     * tokens have become invalid.\n     */\n    function setTotalShares(uint256 _newTotalShares) external onlyOwner() {\n        require(_newTotalShares >= totalValidSupply(), \"below supply\");\n        totalShares = _newTotalShares;\n    }\n\n    /**\n     * Allows the issuer to make public announcements that are visible on the blockchain.\n     */\n    function announcement(string calldata message) external onlyOwner() {\n        emit Announcement(message);\n    }\n\n    /**\n     * See parent method for collateral requirements.\n     */\n    function setCustomClaimCollateral(address collateral, uint256 rate) external onlyOwner() {\n        super._setCustomClaimCollateral(collateral, rate);\n    }\n\n    function getClaimDeleter() public virtual override view returns (address) {\n        return owner;\n    }\n\n    /**\n     * Signals that the indicated tokens have been declared invalid (e.g. by a court ruling in accordance\n     * with article 973g of the Swiss Code of Obligations) and got detached from\n     * the underlying shares. Invalid tokens do not carry any shareholder rights any more.\n     *\n     * This function is purely declarative. It does not technically immobilize the affected tokens as\n     * that would give the issuer too much power.\n     */\n    function declareInvalid(address holder, uint256 amount, string calldata message) external onlyOwner() {\n        uint256 holderBalance = balanceOf(holder);\n        require(amount <= holderBalance);\n        invalidTokens += amount;\n        emit TokensDeclaredInvalid(holder, amount, message);\n    }\n\n    /**\n     * The total number of valid tokens in circulation. In case some tokens have been declared invalid, this\n     * number might be lower than totalSupply(). Also, it will always be lower than or equal to totalShares().\n     */\n    function totalValidSupply() public view returns (uint256) {\n        return totalSupply() - invalidTokens;\n    }\n\n    /**\n     * Allows the company to tokenize shares. If these shares are newly created, setTotalShares must be\n     * called first in order to adjust the total number of shares.\n     */\n    function mintAndCall(address shareholder, address callee, uint256 amount, bytes calldata data) external {\n        mint(callee, amount);\n        IERC677Receiver(callee).onTokenTransfer(shareholder, amount, data);\n    }\n\n    function mint(address target, uint256 amount) public onlyOwner {\n        _mint(target, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(totalValidSupply() + amount <= totalShares, \"total\");\n        super._mint(account, amount);\n    }\n\n    function transfer(address to, uint256 value) virtual override(ERC20Recoverable, ERC20Flaggable) public returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n     * Transfers _amount tokens to the company and burns them.\n     * The meaning of this operation depends on the circumstances and the fate of the shares does\n     * not necessarily follow the fate of the tokens. For example, the company itself might call\n     * this function to implement a formal decision to destroy some of the outstanding shares.\n     * Also, this function might be called by an owner to return the shares to the company and\n     * get them back in another form under an according agreement (e.g. printed certificates or\n     * tokens on a different blockchain). It is not recommended to call this function without\n     * having agreed with the company on the further fate of the shares in question.\n     */\n    function burn(uint256 _amount) external {\n        require(_amount <= balanceOf(msg.sender), \"balance\");\n        _transfer(msg.sender, address(this), _amount);\n        _burn(address(this), _amount);\n    }\n\n}"
    },
    "src/ERC20/extensions/ERC20Named.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Flaggable.sol\";\nimport \"../../utils/Ownable.sol\";\n\ncontract ERC20Named is ERC20Flaggable, Ownable {\n\n    string public override name;\n    string public override symbol;\n\n    constructor(address _admin, string memory _name , string memory _symbol, uint8 _decimals) ERC20Flaggable(_decimals) Ownable(_admin) {\n        setNameInternal(_name, _symbol);\n    }\n\n    function setName(string memory _symbol, string memory _name) external onlyOwner {\n        setNameInternal(_symbol, _name);\n    }\n\n    function setNameInternal(string memory _symbol, string memory _name) internal {\n        symbol = _symbol;\n        name = _name;\n        emit NameChanged(_name, _symbol);\n    }\n\n}"
    },
    "src/shares/SharesWithPredecessor.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./Shares.sol\";\n\n/**\n * @title CompanyName AG Shares\n * @author Luzius Meisser, luzius@aktionariat.com\n *\n * These tokens are uncertified shares (Wertrechte according to the Swiss code of obligations),\n * with this smart contract serving as onwership registry (Wertrechtebuch), but not as shareholder\n * registry, which is kept separate and run by the company. This is equivalent to the traditional system\n * of having physical share certificates kept at home by the shareholders and a shareholder registry run by\n * the company. Just like with physical certificates, the owners of the tokens are the owners of the shares.\n * However, in order to exercise their rights (for example receive a dividend), shareholders must register\n * with the company. For example, in case the company pays out a dividend to a previous shareholder because\n * the current shareholder did not register, the company cannot be held liable for paying the dividend to\n * the \"wrong\" shareholder. In relation to the company, only the registered shareholders count as such.\n * Registration requires setting up an account with ledgy.com providing your name and address and proving\n * ownership over your addresses.\n * @notice The main addition is a functionality that allows the user to claim that the key for a certain address is lost.\n * @notice In order to prevent malicious attempts, a collateral needs to be posted.\n * @notice The contract owner can delete claims in case of disputes.\n */\ncontract SharesWithPredecessor is Shares {\n\n    Shares private immutable predecessor;\n\n    constructor(\n        address _predecessor,\n        string memory _symbol,\n        string memory _name,\n        string memory _terms,\n        uint256 _totalShares,\n        address _owner,\n        address _recoveryHub\n    )\n        Shares(_symbol, _name, _terms, _totalShares, _owner, _recoveryHub)\n    {\n        predecessor = Shares(_predecessor);\n    }\n\n    function convertOldShares() external {\n        uint256 balance = predecessor.balanceOf(msg.sender);\n        predecessor.transferFrom(msg.sender, address(this), balance);\n        predecessor.burn(balance);\n        _mint(msg.sender, balance);\n    }\n\n}"
    },
    "src/shares/allowlist/AllowlistShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../../recovery/ERC20Recoverable.sol\";\nimport \"./ERC20Allowlistable.sol\";\nimport \"../../ERC20/extensions/ERC20Named.sol\";\nimport \"../Shares.sol\";\n\ncontract AllowlistShares is Shares, ERC20Allowlistable {\n\n  constructor(\n    string memory _symbol,\n    string memory _name,\n    string memory _terms,\n    uint256 _totalShares,\n    address _recoveryHub,\n    address _owner\n  )\n    Shares(_symbol, _name, _terms, _totalShares, _owner, _recoveryHub)\n    ERC20Allowlistable()\n  {\n    terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\n    IRecoveryHub(address(_recoveryHub)).setRecoverable(false); \n  }\n\n  function getClaimDeleter() public override view returns (address) {\n      return owner;\n  }\n\n  function transfer(address recipient, uint256 amount) override(Shares, ERC20Flaggable) virtual public returns (bool) {\n    return super.transfer(recipient, amount); \n  }\n\n  function _mint(address account, uint256 amount) internal override(Shares, ERC20Flaggable) {\n      super._mint(account, amount);\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Allowlistable, ERC20Flaggable) internal {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n}"
    },
    "src/shares/allowlist/ERC20Allowlistable.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\n\nimport \"../../ERC20/extensions/ERC20Flaggable.sol\";\nimport \"../../utils/Ownable.sol\";\n\n/**\n * \n */\nabstract contract ERC20Allowlistable is ERC20Flaggable, Ownable {\n\n  uint8 private constant TYPE_DEFAULT = 0x0;\n  uint8 private constant TYPE_ALLOWLISTED = 0x1;\n  uint8 private constant TYPE_FORBIDDEN = 0x2;\n  uint8 private constant TYPE_POWERLISTED = 0x4;\n\n  uint8 private constant FLAG_INDEX_ALLOWLIST = 20;\n  uint8 private constant FLAG_INDEX_FORBIDDEN = 21;\n  uint8 private constant FLAG_INDEX_POWERLIST = 22;\n\n  event AddressTypeUpdate(address indexed account, uint8 addressType);\n\n  bool public restrictTransfers;\n\n  constructor(){\n    setApplicableInternal(true);\n  }\n\n  /**\n   * Configures whether the allowlisting is applied.\n   * Also sets the powerlist and allowlist flags on the null address accordingly.\n   * It is recommended to also deactivate the powerlist flag on other addresses.\n   */\n  function setApplicable(bool transferRestrictionsApplicable) external onlyOwner {\n    setApplicableInternal(transferRestrictionsApplicable);\n  }\n\n  function setApplicableInternal(bool transferRestrictionsApplicable) internal {\n    restrictTransfers = true;\n    // if transfer restrictions are applied, we guess that should also be the case for newly minted tokens\n    // if the admin disagrees, it is still possible to change the type of the null address\n    if (transferRestrictionsApplicable){\n      setTypeInternal(address(0x0), TYPE_POWERLISTED);\n    } else {\n      setTypeInternal(address(0x0), TYPE_DEFAULT);\n    }\n  }\n\n  function setType(address account, uint8 typeNumber) public onlyOwner {\n    setTypeInternal(account, typeNumber);\n  }\n\n  function setTypeInternal(address account, uint8 typeNumber) internal {\n    setFlag(account, FLAG_INDEX_ALLOWLIST, typeNumber == TYPE_ALLOWLISTED);\n    setFlag(account, FLAG_INDEX_FORBIDDEN, typeNumber == TYPE_FORBIDDEN);\n    setFlag(account, FLAG_INDEX_POWERLIST, typeNumber == TYPE_POWERLISTED);\n    emit AddressTypeUpdate(account, typeNumber);\n  }\n\n  function setType(address[] calldata addressesToAdd, uint8 value) public onlyOwner {\n    for (uint i=0; i<addressesToAdd.length; i++){\n      setType(addressesToAdd, value);\n    }\n  }\n\n  /**\n   * If true, this address is allowlisted and can only transfer tokens to other allowlisted addresses.\n   */\n  function canReceiveFromAnyone(address account) public view returns (bool) {\n    return hasFlagInternal(account, FLAG_INDEX_ALLOWLIST) || hasFlagInternal(account, FLAG_INDEX_POWERLIST);\n  }\n\n  /**\n   * If true, this address can only transfer tokens to allowlisted addresses and not receive from anyone.\n   */\n  function isForbidden(address account) public view returns (bool){\n    return hasFlagInternal(account, FLAG_INDEX_FORBIDDEN);\n  }\n\n  /**\n   * If true, this address can automatically allowlist target addresses if necessary.\n   */\n  function isPowerlisted(address account) public view returns (bool) {\n    return hasFlagInternal(account, FLAG_INDEX_POWERLIST);\n  }\n\n  /**\n   * Cleans the allowlist and disallowlist flag under the assumption that the\n   * allowlisting is not applicable any more.\n   */\n  function failOrCleanup(address account) internal {\n    require(!restrictTransfers, \"not allowed\");\n    setType(account, TYPE_DEFAULT);\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) override virtual internal {\n    super._beforeTokenTransfer(from, to, amount);\n    if (canReceiveFromAnyone(to)){\n      // ok, transfers to allowlisted addresses are always allowed\n    } else if (isForbidden(to)){\n      // Target is forbidden, but maybe restrictions have been removed and we can clean the flag\n      failOrCleanup(to);\n    } else {\n      if (isPowerlisted(from)){\n        // it is not allowlisted, but we can make it so\n        setType(to, TYPE_ALLOWLISTED);\n      }\n      // if we made it to here, the target must be a free address and we are not powerlisted\n      else if (hasFlagInternal(from, FLAG_INDEX_ALLOWLIST) || isForbidden(from)){\n        // We cannot send to free addresses, but maybe the restrictions have been removed and we can clean the flag?\n        failOrCleanup(from);\n      }\n    }\n  }\n\n}"
    },
    "src/utils/AllowlistHook.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\n/**\n * @title AllowlistHook\n * @author Luzius Meisser, luzius@aktionariat.com\n */\n\nimport \"../interfaces/ITransferHook.sol\";\nimport \"./Ownable.sol\";\n\ncontract AllowlistHook is ITransferHook, Ownable {\n\n    mapping(address => bool) public allowed;\n\n    event AllowListed(address target);\n    event AllowUnlisted(address target);\n\n    constructor(address _owner) Ownable(_owner){\n    }\n\n    function beforeTokenTransfer(address, address to, uint256) external view override {\n        require(allowed[to], \"Target address not allowed\");\n    }\n\n    function allow(address[] calldata many) external onlyOwner() {\n        for (uint i=0; i<many.length; i++){\n            allow(many[i]);\n        }\n    }\n\n    function allow(address target) public onlyOwner() {\n        allowed[target] = true;\n        emit AllowListed(target);\n    }\n\n    function disallow(address[] calldata many) external onlyOwner() {\n        for (uint i=0; i<many.length; i++){\n            disallow(many[i]);\n        }\n    }\n\n    function disallow(address target) public onlyOwner() {\n        delete allowed[target];\n        emit AllowUnlisted(target);\n    }\n\n}"
    },
    "src/interfaces/ITransferHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITransferHook {\n\n    function beforeTokenTransfer(address from, address to, uint256 amount) external;\n\n}\n"
    },
    "src/ERC20/extensions/ERC20Hookable.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\n/**\n * @title CompanyName Shareholder Agreement\n * @author Luzius Meisser, luzius@aktionariat.com\n * @dev These tokens are based on the ERC20 standard and the open-zeppelin library.\n *\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\n * a shareholder agreement that can be found at the URL defined in the constant 'terms'\n * of the 'DraggableCompanyNameShares' contract. The agreement is partially enforced\n * through the Swiss legal system, and partially enforced through this smart contract.\n * In particular, this smart contract implements a drag-along clause which allows the\n * majority of token holders to force the minority sell their shares along with them in\n * case of an acquisition. That's why the tokens are called \"Draggable CompanyName AG Shares.\"\n */\n\nimport \"../../utils/Ownable.sol\";\nimport \"./ERC20Flaggable.sol\";\nimport \"../../interfaces/ITransferHook.sol\";\n\nabstract contract ERC20Hookable is ERC20Flaggable, Ownable {\n\n    address public hook;\n\n    event HookSet(address hook);\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if (hook != address(0)){\n            ITransferHook(hook).beforeTokenTransfer(from, to, amount);\n        }\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function setHook(address _hook) external onlyOwner() {\n        hook = _hook;\n        emit HookSet(_hook);\n    }\n\n}"
    },
    "src/shares/Brokerbot.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../utils/Ownable.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../interfaces/ITokenReceiver.sol\";\nimport \"../interfaces/IERC677Receiver.sol\";\n\ncontract Brokerbot is Ownable {\n\n    address public paymenthub;\n\n    address public immutable base;  // ERC-20 currency\n    address public immutable token; // ERC-20 share token\n\n    address public constant copyright = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D; // Aktionariat AG\n\n    uint256 private price; // current offer price, without drift\n    uint256 public increment; // increment\n\n    uint256 public driftStart;\n    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\n    int256 public driftIncrement;\n\n    uint8 private constant licenseFeeBps = 90;\n\n    uint8 private constant BUYING_ENABLED = 0x1;\n    uint8 private constant SELLING_ENABLED = 0x2;\n    uint8 private constant VERSION = 0x1;\n\n    // more bits to be used by payment hub\n    uint256 public settings = BUYING_ENABLED | SELLING_ENABLED | (VERSION<<248);\n\n    event Trade(address indexed token, address who, bytes ref, int amount, address base, uint totPrice, uint fee, uint newprice);\n\n    constructor(\n        address _shareToken,\n        uint256 _price,\n        uint256 _increment,\n        address _baseCurrency,\n        address _owner\n    )\n        Ownable(_owner)\n    {\n        base = _baseCurrency;\n        token = _shareToken;\n        price = _price;\n        increment = _increment;\n        paymenthub = address(0x3eABee781f6569328143C610700A99E9ceE82cba);\n    }\n\n    function setPrice(uint256 newPrice, uint256 newIncrement) external onlyOwner {\n        anchorPrice(newPrice);\n        increment = newIncrement;\n    }\n\n    function hasDrift() public view returns (bool) {\n        return timeToDrift != 0;\n    }\n\n    // secondsPerStep should be negative for downwards drift\n    function setDrift(uint256 secondsPerStep, int256 newDriftIncrement) external onlyOwner {\n        anchorPrice(getPrice());\n        timeToDrift = secondsPerStep;\n        driftIncrement = newDriftIncrement;\n    }\n\n    function anchorPrice(uint256 currentPrice) private {\n        price = currentPrice;\n        driftStart = block.timestamp;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return getPriceAtTime(block.timestamp);\n    }\n\n    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\n        if (hasDrift()){\n            uint256 passed = timestamp - driftStart;\n            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\n            int256 driftedPrice = int256(price) + drifted;\n            if (driftedPrice < 0){\n                return 0;\n            } else {\n                return uint256(driftedPrice);\n            }\n        } else {\n            return price;\n        }\n    }\n\n    function buy(address from, uint256 paid, bytes calldata ref) internal returns (uint256) {\n        uint shares = getShares(paid);\n        uint costs = notifyTraded(from, shares, ref);\n        if (costs < paid){\n            IERC20(base).transfer(from, paid - costs);\n        }\n        IERC20(token).transfer(from, shares);\n        return shares;\n    }\n\n    function notifyTraded(address from, uint256 shares, bytes calldata ref) internal returns (uint256) {\n        require(hasSetting(BUYING_ENABLED));\n        uint costs = getBuyPrice(shares);\n        price = price + (shares * increment);\n        emit Trade(token, from, ref, int256(shares), base, costs, 0, getPrice());\n        return costs;\n    }\n\n    function notifyTrade(address buyer, uint256 shares, bytes calldata ref) external onlyOwner {\n        notifyTraded(buyer, shares, ref);\n    }\n\n    function notifyTradeAndTransfer(address buyer, uint256 shares, bytes calldata ref) public onlyOwner {\n        notifyTraded(buyer, shares, ref);\n        IERC20(token).transfer(buyer, shares);\n    }\n\n    function notifyTrades(address[] calldata buyers, uint256[] calldata shares, bytes[] calldata ref) external onlyOwner {\n        for (uint i = 0; i < buyers.length; i++) {\n            notifyTraded(buyers[i], shares[i], ref[i]);\n        }\n    }\n\n    function notifyTradesAndTransfer(address[] calldata buyers, uint256[] calldata shares, bytes[] calldata ref) external onlyOwner {\n        for (uint i = 0; i < buyers.length; i++) {\n            notifyTradeAndTransfer(buyers[i], shares[i], ref[i]);\n        }\n    }\n\n    /**\n     * Payment hub might actually have sent another accepted token, including Ether.\n     */\n    function processIncoming(address token_, address from, uint256 amount, bytes calldata ref) public payable returns (uint256) {\n        require(msg.sender == token_ || msg.sender == base || msg.sender == paymenthub);\n        if (token_ == token){\n            return sell(from, amount, ref);\n        } else if (token_ == base){\n            return buy(from, amount, ref);\n        } else {\n            require(false);\n            return 0;\n        }\n    }\n\n    // ERC-677 recipient\n    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) external returns (bool) {\n        processIncoming(msg.sender, from, amount, ref);\n        return true;\n    }\n\n    // ITokenReceiver\n    function onTokenTransfer(address token_, address from, uint256 amount, bytes calldata ref) external {\n        processIncoming(token_, from, amount, ref);\n    }\n\n    function buyingEnabled() external view returns (bool){\n        return hasSetting(BUYING_ENABLED);\n    }\n\n    function sellingEnabled() external view returns (bool){\n        return hasSetting(SELLING_ENABLED);\n    }\n\n    function hasSetting(uint256 setting) private view returns (bool) {\n        return settings & setting == setting;\n    }\n\n    function isDirectSale(bytes calldata ref) internal pure returns (bool) {\n        if (ref.length == 0 || ref.length == 20) {\n            return true; // old format\n        } else {\n            if (ref[0] == bytes1(0x01)){\n                return true;\n            } else if (ref[0] == bytes1(0x02)) {\n                return false;\n            } else {\n                require(false, \"unknown ref\");\n                return true;\n            }\n        }\n    }\n\n\n    function sell(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\n        require(hasSetting(SELLING_ENABLED));\n        uint256 totPrice = getSellPrice(amount);\n        IERC20 baseToken = IERC20(base);\n        uint256 fee = getLicenseFee(totPrice);\n        if (fee > 0){\n            baseToken.transfer(copyright, fee);\n        }\n        if (isDirectSale(ref)){\n            baseToken.transfer(recipient, totPrice - fee);\n        }\n        price -= amount * increment;\n        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, fee, getPrice());\n        return totPrice;\n    }\n\n    function getLicenseFee(uint256 totPrice) public pure returns (uint256) {\n        return totPrice * licenseFeeBps / 10000;\n    }\n\n    function getSellPrice(uint256 shares) public view returns (uint256) {\n        return getPrice(getPrice() - (shares * increment), shares);\n    }\n\n    function getBuyPrice(uint256 shares) public view returns (uint256) {\n        return getPrice(getPrice(), shares);\n    }\n\n    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\n        if (shares == 0) {\n            return 0;\n        } else {\n            uint256 highest = lowest + (shares - 1) * increment;\n            return ((lowest + highest) / 2) * shares;\n        }\n    }\n\n    function getShares(uint256 money) public view returns (uint256) {\n        uint256 currentPrice = getPrice();\n        uint256 min = 0;\n        uint256 max = money / currentPrice;\n        while (min < max){\n            uint256 middle = (min + max)/2;\n            uint256 totalPrice = getPrice(currentPrice, middle);\n            if (money > totalPrice){\n                min = middle + 1;\n            } else {\n                max = middle;\n            }\n        }\n        return min;\n    }\n\n    function withdrawEther(uint256 amount) external ownerOrHub() {\n        payable(msg.sender).transfer(amount); // return change\n    }\n\n    function approve(address erc20, address who, uint256 amount) external onlyOwner() {\n        IERC20(erc20).approve(who, amount);\n    }\n\n    function withdraw(address ercAddress, address to, uint256 amount) external ownerOrHub() {\n        IERC20(ercAddress).transfer(to, amount);\n    }\n\n    function setPaymentHub(address hub) external onlyOwner() {\n        paymenthub = hub;\n    }\n\n    function setSettings(uint256 settings_) external onlyOwner() {\n        settings = settings_;\n    }\n\n    function setEnabled(bool newBuyingEnabled, bool newSellingEnabled) external onlyOwner() {\n        if (newBuyingEnabled != hasSetting(BUYING_ENABLED)){\n            settings ^= BUYING_ENABLED;\n        }\n        if (newSellingEnabled != hasSetting(SELLING_ENABLED)){\n            settings ^= SELLING_ENABLED;\n        }\n    }\n    \n    modifier ownerOrHub() {\n        require(owner == msg.sender || paymenthub == msg.sender, \"not owner\");\n        _;\n    }\n}"
    },
    "src/shares/allowlist/AllowlistDraggableShares.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../../recovery/ERC20Recoverable.sol\";\nimport \"./ERC20Allowlistable.sol\";\nimport \"../draggable/DraggableShares.sol\";\n\ncontract AllowlistDraggableShares is ERC20Allowlistable, ERC20Draggable, ERC20Recoverable {\n\n  string public terms;\n\n  constructor(\n    string memory _terms,\n    address _wrappedToken,\n    uint256 _quorum,\n    uint256 _votePeriod,\n    address _recoveryHub,\n    address _offerFactory,\n    address _oracle,\n    address _owner\n  )\n    ERC20Draggable(_wrappedToken, _quorum, _votePeriod, _offerFactory, _oracle) \n    ERC20Flaggable(0)\n    ERC20Recoverable(_recoveryHub)\n    Ownable(_owner)\n  {\n    terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\n    IRecoveryHub(address(_recoveryHub)).setRecoverable(false); \n  }\n\n  /**\n  * Let the oracle act as deleter of invalid claims. In earlier versions, this was referring to the claim deleter\n  * of the wrapped token. But that stops working after a successful acquisition as the acquisition currency most\n  * likely does not have a claim deleter.\n  */\n  function getClaimDeleter() public view override returns (address) {\n      return getOracle();\n  }\n\n  function transfer(address to, uint256 value) virtual override(ERC20Flaggable, ERC20Recoverable) public returns (bool) {\n      return super.transfer(to, value);\n  }\n  function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Allowlistable, ERC20Draggable, ERC20Flaggable) internal {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n}"
    },
    "src/ERC20/extensions/ERC20Basic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Named.sol\";\n\ncontract ERC20Basic is ERC20Named {\n\n    constructor(address _admin, string memory _name , string memory _symbol, uint8 _decimals) ERC20Named(_admin, _name, _symbol, _decimals) {\n    }\n\n    function mint(address target, uint256 amount) external onlyOwner {\n        _mint(target, amount);\n    }\n\n}"
    },
    "src/recovery/RecoveryHub.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./IRecoveryHub.sol\";\nimport \"./IRecoverable.sol\";\nimport \"../ERC20/IERC20.sol\";\n\n/**\n * @title Recoverable\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\n * declareLost function to post a deposit and claim that the shares assigned to a specific address are\n * lost. To prevent front running, a commit reveal scheme is used. If he actually is the owner of the shares,\n * he needs to wait for a certain period and can then reclaim the lost shares as well as the deposit.\n * If he is an attacker trying to claim shares belonging to someone else, he risks losing the deposit\n * as it can be claimed at anytime by the rightful owner.\n * Furthermore, if \"getClaimDeleter\" is defined in the subclass, the returned address is allowed to\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\n * function.\n */\n\ncontract RecoveryHub is IRecoveryHub {\n\n    // A struct that represents a claim made\n    struct Claim {\n        address claimant; // the person who created the claim\n        uint256 collateral; // the amount of collateral deposited\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\n        address currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\n    }\n\n    mapping(address => mapping (address => Claim)) public claims; // there can be at most one claim per token and claimed address\n    mapping(address => bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\n\n    event ClaimMade(address indexed token, address indexed lostAddress, address indexed claimant, uint256 balance);\n    event ClaimCleared(address indexed token, address indexed lostAddress, uint256 collateral);\n    event ClaimDeleted(address indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\n    event ClaimResolved(address indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\n\n    function setRecoverable(bool enabled) external override {\n        recoveryDisabled[msg.sender] = !enabled;\n    }\n\n    /**\n     * Some users might want to disable claims for their address completely.\n     * For example if they use a deep cold storage solution or paper wallet.\n     */\n    function isRecoveryEnabled(address target) public view returns (bool) {\n        return !recoveryDisabled[target];\n    }\n\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\n    * 2) The \"lost\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\n    *    whenever someone transfers funds to let claims be resolved automatically when the \"lost\" private key is\n    *    used again.\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\n    *    rightful owner of the deposit.\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\n    * through a shareholder register).\n    */\n    function declareLost(address token, address collateralType, address lostAddress) external {\n        require(isRecoveryEnabled(lostAddress), \"disabled\");\n        uint256 collateralRate = IRecoverable(token).getCollateralRate(collateralType);\n        require(collateralRate > 0, \"bad collateral\");\n        address claimant = msg.sender;\n        uint256 balance = IERC20(token).balanceOf(lostAddress);\n        uint256 collateral = balance * collateralRate;\n        IERC20 currency = IERC20(collateralType);\n        require(balance > 0, \"empty\");\n        require(claims[token][lostAddress].collateral == 0, \"already claimed\");\n        require(currency.transferFrom(claimant, address(this), collateral));\n\n        claims[token][lostAddress] = Claim({\n            claimant: claimant,\n            collateral: collateral,\n            timestamp: block.timestamp,\n            currencyUsed: collateralType\n        });\n\n        IRecoverable(token).notifyClaimMade(lostAddress);\n        emit ClaimMade(token, lostAddress, claimant, balance);\n    }\n\n    function getClaimant(address token, address lostAddress) external view returns (address) {\n        return claims[token][lostAddress].claimant;\n    }\n\n    function getCollateral(address token, address lostAddress) external view returns (uint256) {\n        return claims[token][lostAddress].collateral;\n    }\n\n    function getCollateralType(address token, address lostAddress) external view returns (address) {\n        return claims[token][lostAddress].currencyUsed;\n    }\n\n    function getTimeStamp(address token, address lostAddress) external view returns (uint256) {\n        return claims[token][lostAddress].timestamp;\n    }\n\n    /**\n     * Clears a claim after the key has been found again and assigns the collateral to the \"lost\" address.\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\n     */\n    function clearClaimFromToken(address holder) external override {\n        clearClaim(msg.sender, holder);\n    }\n\n    function clearClaimFromUser(address token) external {\n        clearClaim(token, msg.sender);\n    }\n\n    function clearClaim(address token, address holder) private {\n        Claim memory claim = claims[token][holder];\n        if (claim.collateral != 0) {\n            IERC20 currency = IERC20(claim.currencyUsed);\n            delete claims[token][holder];\n            require(currency.transfer(address(this), claim.collateral), \"could not return collateral\");\n            emit ClaimCleared(token, holder, claim.collateral);\n            IRecoverable(token).notifyClaimDeleted(holder);\n        }\n    }\n\n   /**\n    * After the claim period has passed, the claimant can call this function to send the\n    * tokens on the lost address as well as the collateral to himself.\n    */\n    function recover(address token, address lostAddress) external {\n        Claim memory claim = claims[token][lostAddress];\n        address claimant = claim.claimant;\n        require(claimant == msg.sender, \"not claimant\");\n        uint256 collateral = claim.collateral;\n        IERC20 currency = IERC20(claim.currencyUsed);\n        require(collateral != 0, \"not found\");\n        require(claim.timestamp + IRecoverable(token).claimPeriod() <= block.timestamp, \"too early\");\n        delete claims[token][lostAddress];\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\n        require(currency.transfer(claimant, collateral));\n        IRecoverable(token).recover(lostAddress, claimant);\n        emit ClaimResolved(token, lostAddress, claimant, collateral);\n    }\n\n    /**\n     * This function is to be executed by the claim deleter only in case a dispute needs to be resolved manually.\n     */\n    function deleteClaim(address lostAddress) external override {\n        address token = msg.sender;\n        Claim memory claim = claims[token][lostAddress];\n        IERC20 currency = IERC20(claim.currencyUsed);\n        require(claim.collateral != 0, \"not found\");\n        delete claims[token][lostAddress];\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\n        require(currency.transfer(claim.claimant, claim.collateral));\n        emit ClaimDeleted(token, lostAddress, claim.claimant, claim.collateral);\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}